[English](README.md)

# 通用的 Unity 线性渐变组件

一个为 Unity 设计的灵活的动画组件，可以对任意组件的属性进行平滑的插值动画，只要该属性的类型支持基本的算术运算。它提供了简洁的 `Run` 和 `RunAsync` API，无论是 Unity 的标准类型还是您自己编写的自定义类或结构体，都可以轻松创建动画。

## 实现原理

该组件采用了一种强大的**双策略方法**来处理动画：

1.  **原生类型的优化路径**：对于 Unity 的常见类型，组件会使用一个预先配置的字典，将类型直接映射到 Unity 内部高度优化的原生 `Lerp` 方法。
2.  **通用类型的降级方案**：如果一个类型不在字典中（例如您自定义的结构体），组件会利用 **表达式树 (Expression Trees)** 在运行时动态生成一个高性能的 `Lerp` 函数。

当您启动一个动画时，流程如下：
- 组件首先使用 C# **反射 (Reflection)** 来获取目标属性的初始值。
- 接着启动一个**协程 (Coroutine)**，其运行时长为您指定的动画时间。
- 在协程的每一帧中，它会根据上述两种策略之一计算出新的插值，并更新属性的值。

## 支持的类型

### 1. 原生支持的类型 (优化路径)

通过一个静态字典，组件可以直接调用以下类型的高性能 `Lerp` 函数：
- `int`
- `float`
- `decimal`
- `Vector2`
- `Vector3`
- `Vector4`
- `Color`

### 2. 自定义类型 (通用路径)

如果某个类型不在上面的列表中，或者它是我自己编写的类/结构体，该怎么办？

没问题。只要这个类型支持以下运算符，通用的降级方案就会自动生效：
- **加法** (`T + T`)
- **减法** (`T - T`)
- **乘法** (`T * float`)

这意味着你可以为你自己的数据结构创建动画，而无需编写任何额外的模板代码。

## 表达式树的实现原理

“线性插值 (Lerp)” 的核心是数学公式：`start + (end - start) * t`。

C# 不支持直接对泛型 T 进行数学运算。这正是表达式树发挥作用的地方。它允许我们在运行时构建一个代码的对象模型，然后将其编译成可执行的委托。

具体过程如下：
1.  我们为 `start`、`end` 和 `t` 定义参数表达式。
2.  使用 `Expression.Subtract`、`Expression.Multiply` 和 `Expression.Add` 等表达式节点，一步步地构建出完整的公式。
3.  将这个表达式树包装在一个 Lambda 表达式中。
4.  最后，调用该 Lambda 表达式的 `.Compile()` 方法。这一步会将表达式树转换成一个**高效的委托** (例如 `Func<T, T, float, T>`)，它可以像普通 C# 方法一样被调用。

这个编译过程只会在某个新类型第一次被使用时自动发生。

## 性能优化：智能缓存机制

编译表达式树是一个相对耗时的操作，如果每一帧都执行一次，会严重影响性能。为了解决这个问题，组件采用了一套智能的自动缓存系统。

编译好的委托被存储在一个**静态泛型嵌套类** (`private static class Cache<T>`) 中。

这个方法之所以高效，原因如下：
- **一次性编译**：.NET 运行时确保了泛型类型的静态字段在**每个具体类型上只会被初始化一次**。例如，`Cache<Vector3>` 和 `Cache<MyCustomStruct>` 会被视为两个完全不同的类型，它们各自的初始化代码都只会执行一次。
- **自动缓存**：当你第一次为一个 `MyCustomStruct` 类型创建动画时，表达式树会被编译，其结果（一个委托）被存储在 `Cache<MyCustomStruct>` 的一个 `static readonly` 字段中。
- **高速访问**：之后每一次你需要为 `MyCustomStruct` 创建动画时，组件都会直接从缓存中获取那个已经编译好的委托。这个过程非常快，其性能几乎与调用一个常规的、预先编译好的方法没有差别。

简而言之，当一个新的自定义类型第一次被用于动画时，会产生一次性的微小性能开销。此后，该类型的所有动画都将以最高性能运行。
